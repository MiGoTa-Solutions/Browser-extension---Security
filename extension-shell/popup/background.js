const v="tab_lock_",k="locked_urls",y="lock_pin_map",s=(...t)=>console.log("[SecureShield]",...t);let l=new Map,g=new Map,P=!1;function $(t){if(!t)return null;try{const{hostname:e}=new URL(t);return e?e.replace(/^www\./,"").toLowerCase():null}catch{return t.toLowerCase()}}async function O(){return new Promise(t=>{chrome.storage.local.get([k,y],e=>{s("Loading from storage:",e),e[k]?(l=new Map,Object.entries(e[k]).forEach(([o,a])=>{const r=$(o);r&&l.set(r,Number(a))}),s(`Loaded ${l.size} locked hostnames from storage:`,Array.from(l.entries()))):s("No locked URLs found in storage"),e[y]?(g=new Map(Object.entries(e[y]).map(([o,a])=>[Number(o),a])),s(`Loaded ${g.size} PIN mappings from storage:`,Array.from(g.keys()))):s("No PIN mappings found in storage"),P=!0,t()})})}O();self.addEventListener("install",()=>{s("Service worker installed")});self.addEventListener("activate",()=>{s("Service worker activated")});chrome.tabs.onCreated.addListener(t=>{s("New tab created:",t.id,t.url),t.url&&t.id&&I(t.url)!==null&&s("üö´ New tab created for locked URL, will inject overlay when loaded:",t.url)});chrome.tabs.onUpdated.addListener(async(t,e,o)=>{if(e.status==="complete"&&o.url&&I(o.url)===null)try{const n=new URL(o.url).hostname,c=(await chrome.storage.local.get(["websiteFrequency"])).websiteFrequency||{};c[n]=(c[n]||0)+1,await chrome.storage.local.set({websiteFrequency:c}),s(`Visit count for ${n}: ${c[n]}`)}catch{}if(e.url){let a=I(e.url);a===null&&l.size>0&&(await E(),a=I(e.url)),a!==null&&s("üö´ URL changed to locked site, will inject overlay:",e.url)}});chrome.webNavigation.onBeforeNavigate.addListener(async t=>{if(t.frameId!==0)return;const e=t.url;let o=I(e);if(o===null&&l.size>0&&(await E(),o=I(e)),s(`Navigation check: ${e} -> Lock ID: ${o}, Total locked URLs: ${l.size}`),o!==null){const a=g.has(o);a&&g.get(o),s(`üîí Navigation to locked URL: ${e} (Lock ID: ${o}, Has PIN: ${a})`)}});chrome.runtime.onMessage.addListener((t,e,o)=>{const{action:a,payload:r}=t,n=u=>{u.then(c=>o({success:!0,data:c})).catch(c=>{s(`Action ${a} failed`,c.message),o({success:!1,error:c.message})})};switch(a){case"GET_CURRENT_TABS":n(M());break;case"GET_ACTIVE_TAB":n(j());break;case"GET_LOCKED_URLS":n(Promise.resolve(Array.from(l.keys())));break;case"CHECK_IF_LOCKED":{const d=r==null?void 0:r.url;if(d){const f=I(d),w=f!==null?g.get(f):void 0;o({success:!0,locked:f!==null,lockId:f||void 0,hasPin:f!==null?g.has(f):!1,pin:w})}else o({success:!1,error:"Missing URL"});return!1}case"VERIFY_PIN":{const{lockId:d,pin:f}=r||{};if(d===void 0||!f)return o({success:!1,error:"Missing lockId or PIN"}),!1;const w=g.get(d);return o({success:!0,valid:w?w===f:!0}),!1}case"LOCK_TABS":if(!(r!=null&&r.lockId)||!r.tabs)return o({success:!1,error:"Missing lockId or tabs"}),!1;n(K(r.lockId,r.tabs,r.pin,{skipClosingTabs:!!r.keepTabsOpen}));break;case"UNLOCK_TABS":if(!(r!=null&&r.lockId))return o({success:!1,error:"Missing lockId"}),!1;n(F(r.lockId,r.pin).then(async()=>{await E()}));break;case"SYNC_NOW":n(E());break;case"CHECK_DUPLICATE":if(!(r!=null&&r.url))return o({success:!1,error:"Missing URL"}),!1;const u=$(r.url),c=u?l.has(u):!1,h=c&&u?l.get(u):null;return o({success:!0,data:{isDuplicate:c,lockId:h,hostname:u}}),!1;case"CREATE_LOCK":if(!(r!=null&&r.token)||!r.data)return o({success:!1,error:"Missing token or data"}),!1;n(D(r.token,r.data).then(async d=>(await E(),d)));break;default:return o({success:!1,error:"Unknown action"}),!1}return!0});async function D(t,e){const o="http://localhost:4000/api";s("Creating lock via API:",{name:e.name,tabCount:e.tabs.length,hasToken:!!t});const a=[];for(const u of e.tabs){const c=$(u.url);if(c&&l.has(c)){const h=l.get(c);a.push(`${c} (Lock ID: ${h})`)}}if(a.length>0)throw s("‚ö†Ô∏è Duplicate domain(s) detected:",a),new Error(`This website is already locked. Please unlock it first before locking again.

Already locked: ${a.join(", ")}`);const r=await fetch(`${o}/locks`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`},body:JSON.stringify(e)});if(s("API Response:",{status:r.status,ok:r.ok}),!r.ok){const u=await r.json().catch(()=>({message:"Failed to create lock"}));throw s("API Error:",u),new Error(u.message||"Failed to create lock")}const n=await r.json();return s("Lock created successfully:",n),n}async function M(){return(await chrome.tabs.query({currentWindow:!0})).filter(e=>!!e.url&&!_(e.url)).map(e=>({title:e.title||new URL(e.url).hostname,url:e.url}))}async function j(){const e=(await chrome.tabs.query({active:!0,currentWindow:!0}))[0];if(!(e!=null&&e.url)||_(e.url))throw new Error("No active tab available for locking");return{title:e.title||new URL(e.url).hostname,url:e.url}}async function K(t,e,o,a){s(`Locking tabs for lock ${t} with${o?"":"out"} PIN`),s("Tabs to lock:",e);const r=await chrome.tabs.query({currentWindow:!0}),n=[],u=new Set,c=!(a!=null&&a.skipClosingTabs);o&&g.set(t,o);for(const L of e){const m=$(L.url);m&&(l.set(m,t),u.add(m),s(`Added to locked URLs: ${m} -> Lock ID ${t}`))}s(`Total locked URLs after update: ${l.size}`,Array.from(l.entries()));const h={[k]:Object.fromEntries(l),[y]:Object.fromEntries(g)};s("Data being stored:",h),await chrome.storage.local.set(h),s("Persisted to storage: locked URLs and PINs");const d=await chrome.storage.local.get([k,y]);if(s("Storage verification after write:",d),c)for(const L of r){if(!L.url||typeof L.id!="number")continue;const m=$(L.url);m&&u.has(m)&&n.push(L.id)}const f=`${v}${t}`,w={lockId:t,tabs:e,tabIds:n,timestamp:Date.now(),pin:o};await chrome.storage.local.set({[f]:w}),s(`Stored ${e.length} tab definitions (closing ${n.length})`),c&&n.length&&(await chrome.tabs.remove(n),s(`Closed ${n.length} tabs`))}async function F(t,e){s(`Unlocking tabs for lock ${t}`);const o=g.get(t);if(o&&o!==e)throw new Error("Invalid PIN");const a=`${v}${t}`,n=(await chrome.storage.local.get(a))[a];if(!n){s(`No stored state found for lock ${t}`);return}const u=new Set;for(const h of n.tabs){const d=$(h.url);d&&(l.delete(d),u.add(d))}g.delete(t),await chrome.storage.local.set({[k]:Object.fromEntries(l),[y]:Object.fromEntries(g)});const c=await chrome.tabs.query({});for(const h of c)if(h.url&&h.id){const d=$(h.url);d&&u.has(d)&&chrome.tabs.reload(h.id).catch(f=>s("Failed to reload tab:",f))}for(const h of n.tabs)try{await chrome.tabs.create({url:h.url,active:!1})}catch(d){s(`Failed to reopen tab ${h.url}`,d)}await chrome.storage.local.remove(a),s(`Cleared stored state for lock ${t}`)}function _(t){return t.startsWith("chrome://")||t.startsWith("chrome-extension://")||t.startsWith("about:")}let U=0;const S=3,B=2e3;let N=!1,p=0;const W=3e4;async function E(t=!1,e=!1){var o;try{const r=(await chrome.storage.local.get(["secureShield.auth"]))["secureShield.auth"];if(!(r!=null&&r.token)){const i=Date.now();if(N||(s("No auth token found, skipping database sync"),N=!0),!e&&i-p<W)return;p=i;return}N=!1,p=0,s(`Syncing locks from database... ${t?`(Retry ${U}/${S})`:""}`);const n=new AbortController,u=setTimeout(()=>n.abort(),5e3),c=await fetch("http://localhost:4000/api/locks",{headers:{Authorization:`Bearer ${r.token}`,"Content-Type":"application/json"},signal:n.signal});if(clearTimeout(u),!c.ok)throw new Error(`Sync failed with status: ${c.status}`);const d=(await c.json()).locks||[];s(`Database returned ${d.length} locks`);const f=await chrome.storage.local.get([k,y]),w=new Map,L=new Map;f[k]&&Object.entries(f[k]).forEach(([i,C])=>{w.set(i,Number(C))}),f[y]&&Object.entries(f[y]).forEach(([i,C])=>{L.set(Number(i),C)}),s(`Current local locks: ${w.size} URLs, ${L.size} PINs`);const m=new Map(w),T=new Map(L);d.forEach(i=>{var C;s(`Processing lock ${i.id}: status=${i.status}, tabs=${((C=i.tabs)==null?void 0:C.length)||0}`),i.status==="locked"&&Array.isArray(i.tabs)&&i.tabs.forEach(A=>{const b=$(A.url);b&&(m.has(b)?s(`‚ö†Ô∏è Duplicate URL detected: ${b} (existing Lock ID: ${m.get(b)}, new Lock ID: ${i.id})`):(m.set(b,i.id),s(`Added from database: ${b} -> Lock ID ${i.id}`)))}),i.status==="unlocked"&&Array.isArray(i.tabs)&&(i.tabs.forEach(A=>{const b=$(A.url);b&&m.get(b)===i.id&&(m.delete(b),s(`Removed unlocked URL from local: ${b}`))}),T.has(i.id)&&(T.delete(i.id),s(`Removed PIN for unlocked lock ${i.id}`)))}),l=m,g=T;const R=Object.fromEntries(l.entries()),z=Object.fromEntries(g.entries());await chrome.storage.local.set({[k]:R,[y]:z}),s(`‚úÖ Synced and merged: ${l.size} locked URLs, ${g.size} PINs`),U=0}catch(a){if(s("‚ùå Error syncing locks from database:",a),U<S){U++;const r=B*U;s(`Retrying sync in ${r}ms...`),setTimeout(()=>E(!0),r)}else s("‚ö†Ô∏è Max sync retries reached. Using cached lock data."),U=0,(o=chrome.notifications)==null||o.create({type:"basic",iconUrl:"icons/icon48.png",title:"SecureShield Sync Warning",message:"Unable to sync locks from server. Using cached data."}).catch(()=>{})}}E(!1,!0);setInterval(()=>E(),3e4);chrome.storage.onChanged.addListener((t,e)=>{e==="local"&&t[k]&&(s("Locked URLs changed in storage, syncing..."),E())});function I(t){if(_(t))return null;if(!P)return s("‚ö†Ô∏è Storage not yet initialized, deferring lock check"),null;const e=$(t);return e&&l.get(e)||null}
